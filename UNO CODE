// Auto Waste Bin - UNO (HC-SR04 + Servo + LED) - Hysteresis + Robust Recovery
// Pins: TRIG=D12, ECHO=D11, SERVO=D9, LED=D8
// Serial: 115200
//
// Features:
// - Median of only valid samples (ignores -1 timeouts)
// - Soft sensor/servo recovery after prolonged no-echo
// - Smooth servo movement, hysteresis for stable open/close
// - Optional/WDT block commented (hard reset if MCU locks)

#include <Servo.h>
// #include <avr/wdt.h> // uncomment if you want to enable AVR watchdog (advanced)

const int TRIG_PIN = 12;
const int ECHO_PIN = 11;
const int LED_PIN  = 8;
const int SERVO_PIN = 9;

const int THRESH_CM = 23;             // threshold to open lid (cm)
const unsigned long OPEN_MS = 2500UL; // base open time (ms)
const int MEDIAN_SAMPLES = 5;         // must be odd
const unsigned long DIST_PRINT_INTERVAL = 600UL; // ms between distance prints

// Hysteresis / debounce
const int DETECT_REQUIRED = 3; // consecutive valid detections to open
const int MISS_REQUIRED   = 3; // consecutive misses to consider "gone" and eventually close

// Servo tuning (change if needed)
// --- 70° travel: closed = 160, open = 90 (160 - 90 = 70) ---
const int SERVO_CLOSED_ANGLE = 160;   // Closed position (degrees)
const int SERVO_OPEN_ANGLE   = 90;    // Open position (degrees) -> 70° travel
const int MAX_SERVO_ANGLE    = 180;   // hard clamp
const int SERVO_STEP_DELAY_MS = 6;    // smooth movement step delay (ms)

Servo lidServo;

bool isOpen = false;
unsigned long openUntil = 0;
unsigned long lastPrint = 0;
unsigned long lastOpenTime = 0;
int currentServoAngle = SERVO_CLOSED_ANGLE;

int detectCounter = 0;
int missCounter = 0;

// Recovery related
const unsigned long SENSOR_RECOVER_AFTER_MS = 10000UL; // 10s of no valid echoes triggers recovery
unsigned long lastValidEchoAt = 0;

/////////////////////////////////////////////////////////////////////////
// Basic ultrasonic measurement (single shot). Returns -1 on timeout.
/////////////////////////////////////////////////////////////////////////
long measureOnce() {
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);

  unsigned long duration = pulseIn(ECHO_PIN, HIGH, 30000UL); // 30 ms timeout
  if (duration == 0) return -1; // timeout, no echo
  long cm = duration / 58; // approximate
  return cm;
}

/////////////////////////////////////////////////////////////////////////
// Median of only valid samples; return -1 only if all samples timed out
/////////////////////////////////////////////////////////////////////////
long measureMedian() {
  long a[MEDIAN_SAMPLES];
  int filled = 0;
  for (int i = 0; i < MEDIAN_SAMPLES; ++i) {
    long v = measureOnce();
    delay(20);
    if (v >= 0) {
      a[filled++] = v;
    }
  }
  if (filled == 0) return -1; // all timeouts -> signal no echo

  // insertion sort for small array
  for (int i = 1; i < filled; ++i) {
    long key = a[i];
    int j = i - 1;
    while (j >= 0 && a[j] > key) {
      a[j + 1] = a[j];
      j--;
    }
    a[j + 1] = key;
  }
  return a[filled / 2];
}

/////////////////////////////////////////////////////////////////////////
// Smoothly move servo to 'toAngle'
/////////////////////////////////////////////////////////////////////////
void moveServoSmooth(int toAngle) {
  toAngle = constrain(toAngle, 0, MAX_SERVO_ANGLE);
  if (toAngle == currentServoAngle) return;
  if (toAngle > currentServoAngle) {
    for (int a = currentServoAngle; a <= toAngle; ++a) {
      lidServo.write(a);
      delay(SERVO_STEP_DELAY_MS);
    }
  } else {
    for (int a = currentServoAngle; a >= toAngle; --a) {
      lidServo.write(a);
      delay(SERVO_STEP_DELAY_MS);
    }
  }
  currentServoAngle = toAngle;
}

/////////////////////////////////////////////////////////////////////////
// Action helpers
/////////////////////////////////////////////////////////////////////////
void openLid() {
  digitalWrite(LED_PIN, HIGH);
  Serial.println(">> ACTION: Lid OPEN");
  moveServoSmooth(SERVO_OPEN_ANGLE);
  isOpen = true;
  openUntil = millis() + OPEN_MS;
  lastOpenTime = millis();
  detectCounter = 0;
  missCounter = 0;
}

void closeLid() {
  digitalWrite(LED_PIN, LOW);
  Serial.println(">> ACTION: Lid CLOSE");
  moveServoSmooth(SERVO_CLOSED_ANGLE);
  isOpen = false;
  detectCounter = 0;
  missCounter = 0;
}

/////////////////////////////////////////////////////////////////////////
// Soft recovery: toggle TRIG, re-init pins, reattach servo, blink LED.
// This tries to recover the sensor and servo without full power cycle.
/////////////////////////////////////////////////////////////////////////
void attemptSensorRecovery() {
  Serial.println("!! RECOVER: Attempting sensor/servo recovery");

  // Ensure trig is output and briefly toggle
  pinMode(TRIG_PIN, OUTPUT);
  digitalWrite(TRIG_PIN, LOW);
  delay(50);
  for (int i = 0; i < 3; ++i) {
    digitalWrite(TRIG_PIN, HIGH);
    delayMicroseconds(15);
    digitalWrite(TRIG_PIN, LOW);
    delay(50);
  }

  // Reinitialize echo pin and servo
  pinMode(ECHO_PIN, INPUT);

  // Reattach servo (some drivers like a detach/attach)
  lidServo.detach();
  delay(50);
  lidServo.attach(SERVO_PIN);
  lidServo.write(currentServoAngle);

  // Blink LED to show recovery attempt
  for (int i = 0; i < 3; ++i) {
    digitalWrite(LED_PIN, HIGH);
    delay(80);
    digitalWrite(LED_PIN, LOW);
    delay(80);
  }

  // Give the sensor a moment; update last valid echo time to avoid repeated recovery calls
  lastValidEchoAt = millis();
}

void setup() {
  Serial.begin(115200);
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(TRIG_PIN, LOW);
  digitalWrite(LED_PIN, LOW);

  lidServo.attach(SERVO_PIN);
  lidServo.write(SERVO_CLOSED_ANGLE);
  currentServoAngle = SERVO_CLOSED_ANGLE;

  lastValidEchoAt = millis();

  Serial.println("Auto Waste Bin - UNO (Hysteresis+Robust Recovery) - 70deg travel (160->90)");
  Serial.println("Serial: 115200");

  // OPTIONAL: enable WDT here if you want a hard reset when the MCU locks.
  // Use with caution! Uncomment both lines below to enable a ~2s watchdog:
  // wdt_enable(WDTO_2S);
  // wdt_reset();
}

void loop() {
  // If using watchdog, pet it:
  // wdt_reset(); // uncomment if WDT enabled

  long dist = measureMedian(); // median filtered reading (ignores timeouts)
  unsigned long now = millis();

  // Update last valid echo timestamp if we got a valid reading
  if (dist >= 0) lastValidEchoAt = now;

  // Periodic status print
  if (now - lastPrint >= DIST_PRINT_INTERVAL) {
    if (dist == -1) Serial.print("Distance: No echo");
    else {
      Serial.print("Distance: ");
      Serial.print(dist);
      Serial.print(" cm");
    }
    Serial.print("  | detectCnt=");
    Serial.print(detectCounter);
    Serial.print(" missCnt=");
    Serial.println(missCounter);
    lastPrint = now;
  }

  // If we've had no valid echoes for a while, attempt soft recovery
  if ((now - lastValidEchoAt) > SENSOR_RECOVER_AFTER_MS) {
    attemptSensorRecovery();
  }

  // Update detection counters
  if (dist > 0 && dist <= THRESH_CM) {
    detectCounter++;
    missCounter = 0;
  } else {
    missCounter++;
    detectCounter = 0;
  }

  // Open on stable detections
  if (!isOpen && detectCounter >= DETECT_REQUIRED && (now - lastOpenTime) > 250) {
    openLid();
  }

  // While open, extend if object present; close on stable misses
  if (isOpen) {
    if (dist > 0 && dist <= THRESH_CM) {
      openUntil = now + OPEN_MS; // extend
    } else {
      if (missCounter >= MISS_REQUIRED && now >= openUntil) {
        closeLid();
      }
    }
  }

  delay(60); // small loop delay
}
